
## 题目

```
在一根无限长的数轴上，你站在0的位置。终点在target的位置。

每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。

返回到达终点需要的最小移动次数。

示例 1:

输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。

示例 2:

输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。  

```

## 解析

```C++
class Solution {
public:
    int reachNumber(int target) {
        // 理解这题的意思 这题就好做了
        // 分析 首先考虑一种比较极端的情况 即一直向正方向移动n步 ，刚好达到target 
        // 那么target的值就等于前n步的和 ，也就是1+2+.....+n = n*(n+1)/2
        // 如果n(n+1)/2>target ,那么所需要的步数肯定要比n多，而且肯定有向左走的步子，也就是求和的时候肯定是有负数的，至于哪个或者哪些个为负，下面开始讨论
        //1，n(n+1)/2 - target 为偶数时，所以要想到达 target 需要向左走 n(n+1)/2 - target 偶数步 ，
        // 就是把前n项中第( n(n+1)/2 - target)/2 步变为负号就行了
        //当n(n+1)/2 - target 为奇数时，就要分类讨论了，若n为奇数n+1就是偶数 无论向左还是向右 都不会产生一个奇数的差来因此需要再走一步故要n+2步
        //若n为偶数，n+1则为奇数，可以产生一个奇数的差，故要n+1步
        if(target<0) return reachNumber(-target) ;
        int i=0 ;          
        while(i*(i+1) < 2*target )
        {
            i++;
        }
 
        if(i*(i+1)/2 == target) return i ;
        else 
        {
            if((i*(i+1)/2-target)%2 == 0) return i;
            else
            {
                if(i%2==0) return i+1 ;
                else return i+2 ;
            }
        }
        
    }
};
```

